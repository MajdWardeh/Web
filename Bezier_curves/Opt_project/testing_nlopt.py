# -*- coding: utf-8 -*-
"""Quadrotor Trajectory Optimization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iAUguveacX4iSsLxujJ_X-LqNi_cRxbt
"""



import numpy as np
import matplotlib.pyplot as plt
import scipy as sp
import nlopt

global steps
global ti

ti = 0           #Initial time
pi = 10          #Initial position
pf = 100         #Final position
vmax = 5        #Maximum velocity
amax = 2         #Maximum acceleration
steps = 1000     #Number of time steps

#Define the trajectory curves
def position(c, t):
  return c[0] + c[1] * t + c[2] * t**2

def velocity(c, t):
  return c[1] + 2 * c[2] * t

def acceleration(c, t):
  return 2 * c[2]

#Define the objective function: minimize T (x[0])
def objective(x, grad):
  if grad.size > 0:
    grad[0] = 1
    grad[1] = 0
    grad[2] = 0
    grad[3] = 0
  return x[0]

#Define the initial position constraint: position(ti) = pi 
def initialPositionConstraint(x, grad, position, pi):
  if grad.size > 0:
    grad[0] = 0
    grad[1] = 1
    grad[2] = ti
    grad[3] = ti**2
  return position(x[1:], ti) - pi
  
#Define the final position constraint: position(T) = pf
def finalPositionConstraint(x, grad, position, pf):
  if grad.size > 0:
    grad[0] = x[2] + 2 * x[3] * x[0]
    grad[1] = 1
    grad[2] = x[0]
    grad[3] = x[0]**2
  return position(x[1:], x[0]) - pf
 
#Define the velocity constraint: velocity(tj) < vmax for every j 
def velocityConstraint(x, grad, velocity, vmax, i):
  if grad.size > 0:
    grad[0] = 2 * x[3] * i / steps
    grad[1] = 0
    grad[2] = 1
    grad[3] = 2 * (x[0] - ti) * i / steps
  return velocity(x[1:], (x[0]-ti)*i/steps) - vmax

#Define the acceleration constraint: acceleration(tj) < amax for every j
def accelerationConstraint(x, grad, acceleration, amax, i):
  if grad.size > 0:
    grad[0] = 0
    grad[1] = 0
    grad[2] = 0
    grad[3] = 2
  return acceleration(x[1:], (x[0]-ti)*i/steps) - amax

#Define the algorithm used: SQP
opt = nlopt.opt(nlopt.LD_SLSQP, 4)

#Define the lower bounds of the optimization parameters
opt.set_lower_bounds([0, -float('inf'), -float('inf'), -float('inf')])

#Set the objective function
opt.set_min_objective(objective)

#Set the equality constraints: postion constraints
opt.add_equality_constraint(lambda x, grad: initialPositionConstraint(x, grad, position, pi), 1e-8)
opt.add_equality_constraint(lambda x, grad: finalPositionConstraint(x, grad, position, pf), 1e-8)

#Set the inequality constraints: velocity and accelereation
for i in range(steps):
  opt.add_inequality_constraint(lambda x, grad: velocityConstraint(x, grad, velocity, vmax, i), 1e-8)
  opt.add_inequality_constraint(lambda x, grad: accelerationConstraint(x, grad, acceleration, amax, i), 1e-8)

#Set tolerance
opt.set_xtol_rel(1e-8)

#Begin optimization with the initial values
x = opt.optimize([1e-4, 1e-4, 1e-4, 1e-4])

print("Optimal Value at ", x[0], x[1], x[2], x[3])
print("Minimum Time = ", x[0])
print("Result = ", opt.last_optimize_result())

ft = []
t = np.linspace(ti, x[0], steps)
for i in range(len(t)):
  ft.append(x[1] + x[2] * t[i] + x[3] * t[i]**2)

print("point A: ", t[0], ", ", ft[0])
print("point B: ", t[-1], ", ", ft[-1])

# plt.xlim(0, x[0])
# plt.ylim(-1000, 200)
plt.scatter(t, ft)
plt.show()